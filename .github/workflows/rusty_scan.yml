name: Distributed Port Scanning (RustScan)

on:
  workflow_dispatch:
    inputs:
      # --- Automated Trigger Inputs ---
      correlation_id:
        description: 'AUTOMATED: The run_id from the parent enumeration workflow'
        required: false
      results_repo_owner:
        description: 'AUTOMATED: Owner of the repo where results are stored'
        required: false
      results_repo_name:
        description: 'AUTOMATED: Name of the repo where results are stored'
        required: false
      # --- Manual Trigger Input ---
      manual_input_file:
        description: 'MANUAL: Path to a massdns.txt formatted file in this repo to scan'
        required: false
        default: ''

permissions:
  contents: write
  actions: write

env:
  # Use automated input if available, otherwise fallback to secrets
  STORE_REPO_NAME: ${{ github.event.inputs.results_repo_name || secrets.STORE }}
  ACCOUNT2_REPO_OWNER: ${{ github.event.inputs.results_repo_owner || secrets.ACCOUNT2_REPO_OWNER }}
  # --- Static Distribution Config ---
  DISTRIBUTION_THRESHOLD: 8
  PRIMARY_PERCENTAGE: 40
  SECONDARY_PERCENTAGE: 35
  ACCOUNT2_REPO_NAME: ${{ secrets.ACCOUNT2_REPO_NAME }}
  ACCOUNT3_REPO_OWNER: ${{ secrets.ACCOUNT3_REPO_OWNER }}
  ACCOUNT3_REPO_NAME: ${{ secrets.ACCOUNT3_REPO_NAME }}

jobs:
  prepare_rustscan_chunks:
    name: Prepare IP Chunks & Package
    runs-on: ubuntu-latest
    outputs:
      all_chunks_matrix_json: ${{ steps.build_matrix.outputs.full_matrix }}
      total_chunks_count: ${{ steps.build_matrix.outputs.total_chunks }}
      chunk_package_artifact_name: "rustscan-chunks-package-${{ github.run_id }}"
    steps:
      - name: Checkout This Repository
        uses: actions/checkout@v4

      - name: Extract IPs from Input Source
        id: extract_ips
        env:
          STORE_RECON_PAT: ${{ secrets.PAT_FOR_SECONDARY_ACCOUNT_REPO }}
          MANUAL_FILE: ${{ github.event.inputs.manual_input_file }}
        run: |
          # --- CONDITIONAL LOGIC FOR INPUT SOURCE ---
          if [[ -n "$MANUAL_FILE" ]]; then
            echo "::notice:: Manual input mode enabled. Reading IPs from '$MANUAL_FILE'."
            if [[ ! -f "$MANUAL_FILE" ]]; then
              echo "::error:: Manual input file '$MANUAL_FILE' not found. Cannot proceed."
              exit 1
            fi
            # Extract 3rd column (IP) from the massdns-formatted file
            awk '{print $3}' "$MANUAL_FILE" | sort -u > all_unique_ips.txt
          else
            echo "::notice:: Automated mode. Cloning results repo to find IPs."
            if [[ -z "${{ env.ACCOUNT2_REPO_OWNER }}" || -z "${{ env.STORE_REPO_NAME }}" ]]; then
                echo "::error:: Automated mode requires results_repo_owner and results_repo_name inputs."
                exit 1
            fi
            git clone --depth 1 "https://x-access-token:${STORE_RECON_PAT}@github.com/${{ env.ACCOUNT2_REPO_OWNER }}/${{ env.STORE_REPO_NAME }}.git" store-recon
            find store-recon/results -type f -name "massdns.txt" -exec awk '{print $3}' {} + | sort -u > all_unique_ips.txt
          fi

          echo "INFO: Found $(wc -l < all_unique_ips.txt) unique IPs to scan."
          if [ ! -s all_unique_ips.txt ]; then
            echo "::warning:: No IPs found to scan. The workflow will finish without scanning."
          fi

      - name: Build Matrix & Create IP Chunks
        id: build_matrix
        run: |
          JSON_MATRIX='[]'
          if [ -s all_unique_ips.txt ]; then
            mkdir -p chunks/all-ips
            split -l 200 -a 4 --numeric-suffixes=1 all_unique_ips.txt "chunks/all-ips/chunk_"
            while IFS= read -r chunk_file_path; do
              JSON_MATRIX=$(printf '%s' "$JSON_MATRIX" | jq -c --arg c "$chunk_file_path" '. + [{chunk:$c}]')
            done < <(find "chunks/all-ips/" -name 'chunk_*' -type f)
          fi
          TOTAL_CHUNKS=$(echo "$JSON_MATRIX" | jq 'length')
          echo "full_matrix=${JSON_MATRIX}" >> $GITHUB_OUTPUT
          echo "total_chunks=${TOTAL_CHUNKS}" >> $GITHUB_OUTPUT

      - name: Package IP Chunks and Upload
        if: steps.build_matrix.outputs.total_chunks > 0
        uses: actions/upload-artifact@v4
        with:
          name: "rustscan-chunks-package-${{ github.run_id }}"
          path: chunks/
          retention-days: 1

  distribute_and_trigger_scanners:
    name: Distribute & Trigger Scanners
    needs: prepare_rustscan_chunks
    if: needs.prepare_rustscan_chunks.outputs.total_chunks_count > 0
    runs-on: ubuntu-latest
    outputs:
      primary_matrix_json: ${{ steps.calculate_distribution.outputs.primary_matrix }}
    steps:
      - name: Calculate Chunk Distribution
        id: calculate_distribution
        shell: bash
        run: |
          ALL_CHUNKS_JSON='${{ needs.prepare_rustscan_chunks.outputs.all_chunks_matrix_json }}'
          TOTAL_CHUNKS=${{ needs.prepare_rustscan_chunks.outputs.total_chunks_count }}
          if [ "$TOTAL_CHUNKS" -lt "$DISTRIBUTION_THRESHOLD" ]; then
            PRIMARY_CHUNKS_JSON="$ALL_CHUNKS_JSON"; SECONDARY_CHUNKS_JSON="[]"; TERTIARY_CHUNKS_JSON="[]"
          else
            PRIMARY_CHUNK_COUNT=$(echo "($TOTAL_CHUNKS * $PRIMARY_PERCENTAGE) / 100" | bc)
            SECONDARY_CHUNK_COUNT=$(echo "($TOTAL_CHUNKS * $SECONDARY_PERCENTAGE) / 100" | bc)
            OFFSET_FOR_TERTIARY=$((PRIMARY_CHUNK_COUNT + SECONDARY_CHUNK_COUNT))
            PRIMARY_CHUNKS_JSON=$(echo "$ALL_CHUNKS_JSON" | jq -c --argjson limit "$PRIMARY_CHUNK_COUNT" '.[0:$limit]')
            SECONDARY_CHUNKS_JSON=$(echo "$ALL_CHUNKS_JSON" | jq -c --argjson offset "$PRIMARY_CHUNK_COUNT" --argjson limit "$SECONDARY_CHUNK_COUNT" '.[$offset : $offset+$limit]')
            TERTIARY_CHUNKS_JSON=$(echo "$ALL_CHUNKS_JSON" | jq -c --argjson offset "$OFFSET_FOR_TERTIARY" '.[$offset:]')
          fi
          echo "primary_matrix=${PRIMARY_CHUNKS_JSON}" >> $GITHUB_OUTPUT
          echo "secondary_matrix=${SECONDARY_CHUNKS_JSON}" >> $GITHUB_OUTPUT
          echo "tertiary_matrix=${TERTIARY_CHUNKS_JSON}" >> $GITHUB_OUTPUT
      # Placeholder for triggering secondary/tertiary workflows. Ensure you have corresponding
      # worker workflows in your other repositories that can accept these inputs.
      # - name: Trigger Secondary and Tertiary Scan Workflows
      #   uses: benc-uk/workflow-dispatch@v1
      #   ...

  run_primary_account_scan:
    name: Run Port Scan (Primary)
    needs: [prepare_rustscan_chunks, distribute_and_trigger_scanners]
    if: needs.prepare_rustscan_chunks.outputs.total_chunks_count > 0 && needs.distribute_and_trigger_scanners.outputs.primary_matrix_json != '[]'
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/pcoder7/spider-puredns-actions:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_TOKEN }}
    strategy:
      fail-fast: false
      matrix:
        pair: ${{ fromJson(needs.distribute_and_trigger_scanners.outputs.primary_matrix_json) }}
    steps:
      - uses: actions/checkout@v4
      - name: Download & Extract IP Chunks
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.prepare_rustscan_chunks.outputs.chunk_package_artifact_name }}
      - run: tar -xzvf *.tar.gz

      - name: Prepare IP-to-Subdomain Mapping File
        env:
          STORE_RECON_PAT: ${{ secrets.PAT_FOR_SECONDARY_ACCOUNT_REPO }}
          MANUAL_FILE: ${{ github.event.inputs.manual_input_file }}
        run: |
          if [[ -n "$MANUAL_FILE" ]]; then
            echo "::notice:: Manual mode. Using local file '$MANUAL_FILE' for IP-to-subdomain mapping."
            if [[ -f "$MANUAL_FILE" ]]; then
              cp "$MANUAL_FILE" full_massdns.txt
            else
              echo "::warning:: Manual input file not found. IP-to-subdomain mapping will be empty."
              touch full_massdns.txt
            fi
          else
            echo "::notice:: Automated mode. Cloning repo for IP-to-subdomain mapping."
            git clone --depth 1 "https://x-access-token:${STORE_RECON_PAT}@github.com/${{ env.ACCOUNT2_REPO_OWNER }}/${{ env.STORE_REPO_NAME }}.git" store-recon
            find store-recon/results -type f -name "massdns.txt" -exec cat {} + > full_massdns.txt
          fi

      - name: Map subdomains to ports (RustScan)
        id: map_subdomains_cdn
        run: |
          IP_CHUNK_FILE=${{ matrix.pair.chunk }}
          PORTS="80,443,8080,8443,3000,8000"
          grep -F -f "$IP_CHUNK_FILE" full_massdns.txt | awk '{ print $3, $1 }' | sort -k1,1 > ip_to_sub.txt || true
          cat "$IP_CHUNK_FILE" | cut-cdn -ua -t 50 -silent -o non_cdn_ips.txt || true
          if [ ! -s non_cdn_ips.txt ]; then echo "No non-CDN IPs to scan in this chunk."; touch subdomain_ports.txt; exit 0; fi
          rustscan -a non_cdn_ips.txt -p "$PORTS" --no-banner -t 4000 --tries 1 -u 5000 -b 600 --greppable --accessible > rustscan_results.txt || true
          awk -F ' -> ' '{ gsub(/[\[\]]/, "", $2); n = split($2, p, ","); for(i=1;i<=n;i++) print $1 ":" p[i] }' rustscan_results.txt > rustscan_ip_ports.txt
          awk -F: 'NF==2{print $1, $2} NF==1{print $1, ""}' rustscan_ip_ports.txt | sort -k1,1 | join - ip_to_sub.txt | awk '{print $3 ":" $2}' > subdomain_ports.txt

      - name: Sort Port Scan Results
        run: |
          mkdir -p results
          if [ ! -s "subdomain_ports.txt" ]; then exit 0; fi
          while read -r line; do
            subdomain=$(echo "$line" | cut -d: -f1)
            parent=$(echo "$subdomain" | rev | cut -d. -f1,2 | rev)
            mkdir -p "results/$parent"
            echo "$line" >> "results/$parent/subdomain_ports.txt"
          done < subdomain_ports.txt

      - name: Upload Primary Account Scan Results
        uses: actions/upload-artifact@v4
        with:
          name: rustscan-results-primary-${{ matrix.pair.chunk }}
          path: results/
          retention-days: 1

  merge_and_commit_scan_results:
    name: Merge, Commit & Notify
    needs: run_primary_account_scan
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download all scan result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: 'rustscan-results-*'
          path: temp-aggregated-results
          merge-multiple: true
      - name: Consolidate all scan results
        id: consolidate
        run: |
          mkdir -p final_results
          if [ ! -d "temp-aggregated-results" ] || [ -z "$(ls -A temp-aggregated-results)" ]; then echo "has_results=false" >> $GITHUB_OUTPUT; exit 0; fi
          find temp-aggregated-results -type f -name "subdomain_ports.txt" | while read -r f; do D=$(basename "$(dirname "$f")"); mkdir -p "final_results/$D"; cat "$f" >> "final_results/$D/subdomain_ports.txt"; done
          find final_results -type f -name "*.txt" -exec sort -u -o {} {} \;
          if [ -z "$(ls -A final_results)" ]; then echo "has_results=false" >> $GITHUB_OUTPUT; else echo "has_results=true" >> $GITHUB_OUTPUT; fi

      - name: Organize and Push Port Results
        if: success() && steps.consolidate.outputs.has_results == 'true' && github.event.inputs.manual_input_file == ''
        env:
          STORE_RECON_PAT: ${{ secrets.PAT_FOR_SECONDARY_ACCOUNT_REPO }}
          CORRELATION_ID: ${{ github.event.inputs.correlation_id }}
        run: |
          git config --global user.name "Recon Bot" && git config --global user.email "bot@github.com"
          git clone "https://x-access-token:${STORE_RECON_PAT}@github.com/${{ env.ACCOUNT2_REPO_OWNER }}/${{ env.STORE_REPO_NAME }}.git" store-recon
          cd store-recon
          for domain_dir in ../final_results/*; do
            domain_name=$(basename "$domain_dir")
            dest_repo_dir="results/$domain_name" && mkdir -p "$dest_repo_dir"
            if [ -f "$domain_dir/subdomain_ports.txt" ]; then
              cat "$domain_dir/subdomain_ports.txt" "$dest_repo_dir/puredns_result.txt" 2>/dev/null | sort -u > "$dest_repo_dir/puredns_result.txt.tmp" && mv "$dest_repo_dir/puredns_result.txt.tmp" "$dest_repo_dir/puredns_result.txt"
            fi
          done
          if git diff --quiet; then echo "No port scan changes to commit."; exit 0; fi
          git add results/
          git commit -m "feat: Add port scan results from scan ID: ${CORRELATION_ID}"
          git push

      - name: Trigger http multiple three
        if: success() && steps.consolidate.outputs.has_results == 'true' && github.event.inputs.manual_input_file == ''
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: http_dispatch_three.yml
          repo: Pcoder7/http-multiple-three
          token: ${{ secrets.PAT_TOKEN }}
          ref: main
          inputs: '{ "run_id": "${{ github.event.inputs.correlation_id }}", "results_repo": "${{ env.ACCOUNT2_REPO_OWNER }}/${{ env.STORE_REPO_NAME }}" }'
